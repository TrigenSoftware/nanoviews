- for loop array or empty check for else
- rework return slot$ to look like element/component? fn.prop is faster than {f,p}
- util to transform static props to signal props?
- rename decide? export as public - as Dynamic in solidjs
- typed effectattrs <T>
- additional arg for record in for$? as$

for$($items)(
  as$(record, ($item) => li()($item.$name))
)

- serialize - start all marked stores?
- bundle types?
- static index for untracked loop?
- controls addEventListener to events system
- lazy scope to start and stop methods? - ??? wtf???
- later: resort effects

do not export all through root index? split entrypoints by groups

import {
  div,
  button
} from 'nanoviews/elements'
import {
  classList$,
  focus$
} from 'nanoviews/attributes'
import {
  signal
} from 'nanoviews/store'
import {
  if$,
  for$
} from 'nanoviews/logic'

vs

import {
  div,
  button,
  classList$,
  focus$,
  signal,
  if$,
  for$
} from 'nanoviews'

there are many exports, so it can look like a mess, may be we can push devs to write structured code by splitting exports by entrypoints.

- !== undefined is faster
- prop: undefined is faster
- for let i faster than array methods
- push(...arr) is slow
- noop faster than check
- getter setter are slow (not in class)
- Reflect.get is slow
- arr.length = 0 is slower than arr = []

- store injection effectScope to stop effects after context stop? - UPD: wtf is this? i dont remember what it mean. Wrap serialize in effectScope? Or wrap inject ? bad practice, maybe just for safety into serialize

- html + head components
- universal dom
- ssr
- hydration

- events modifiers?
- svg ?

- error boundaries

- hmr

- COMPILER to compete with svelte and solid

SSR

- setAttribute
- removeAttribute
- on*
- createElement
- insertBefore
- removeChild
- createTextNode
- data
- attachShadow
- *prop
- style
  - setProperty
  - removeProperty
- portals
- innerHTML

handler = {
  k: undefined,
  get(target, key) {
      if (key[0] === '$') {
        const skey = key.slice(1)
        const keys = this.k

        keys[keys.indexOf(skey)] = key

        return { signal: target[skey] }
      }

      return target[key]
  },
  ownKeys() {
      return this.k
  },
}

function props$(props) {
    const propsHandler = Object.create(handler)

    propsHandler.k = Reflect.ownKeys(props)

    return new Proxy(props, propsHandler)
}

obj = props$({
	a: 1,
	b: '',
	c: true,
	d: null
})
