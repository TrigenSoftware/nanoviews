## Nanoviews

- for loop array or empty check for else
- rework return slot$ to look like element/component? fn.prop is faster than {f,p}
- util to transform static props to signal props?
- rename decide? export as public - as Dynamic in solidjs
- typed effectattrs <T>
- additional arg for record in for$? as$
- controls addEventListener to events system
- static index for untracked loop?

for$($items)(
  as$(record, ($item) => li()($item.$name))
)

## Kida/Agera

- serialize - start all marked stores?
- injectable class

- bundle types?
- lazy scope to start and stop methods? for example for resort in loop
- later: resort effects
- store injection effectScope to stop effects after context stop? - UPD: wtf is this? i dont remember what it mean. Wrap serialize in effectScope? Or wrap inject ? bad practice, maybe just for safety into serialize

## Perf

- !== undefined is faster
- prop: undefined is faster
- for let i faster than array methods
- push(...arr) is slow
- noop faster than check
- getter setter are slow (not in class)
- Reflect.get is slow
- arr.length = 0 is slower than arr = []

## Long distance plans

- html + head components
- universal dom
- ssr
- hydration
- svg ?
- error boundaries
- hmr
- COMPILER to compete with svelte and solid

### SSR

- setAttribute
- removeAttribute
- on*
- createElement
- insertBefore
- removeChild
- createTextNode
- data
- attachShadow
- *prop
- style
  - setProperty
  - removeProperty
- portals
- innerHTML

## Drafts

```
handler = {
  k: undefined,
  get(target, key) {
      if (key[0] === '$') {
        const skey = key.slice(1)
        const keys = this.k

        keys[keys.indexOf(skey)] = key

        return { signal: target[skey] }
      }

      return target[key]
  },
  ownKeys() {
      return this.k
  },
}

function props$(props) {
    const propsHandler = Object.create(handler)

    propsHandler.k = Reflect.ownKeys(props)

    return new Proxy(props, propsHandler)
}

obj = props$({
	a: 1,
	b: '',
	c: true,
	d: null
})
```
